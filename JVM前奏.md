# JVM内存模型
- 运行时数据区
    * 线程独占区
        - 虚拟机栈
        - 本地方法栈
        - 程序计数器
    * 线程共享区
        - 方法区（存储运行时常量池、已被虚拟机加载的类信息、常量、静态变量等数据
        - Java堆（存储对象实例)

#### 程序计数器
- 是一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器
- 程序计数器处于线程独占区
- 如果线程执行的是Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址。如果正在执行native方法，这个计数器的值为undefined
- 此区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError的区域

#### Java虚拟机栈
- 虚拟机栈描述的是Java方法执行的动态内存模型
- 栈帧
    * 每个方法执行，都会创建一个栈帧，伴随着方法从创建到执行完成。用于存储局部变量表，操作数栈，动态链接，方法出口等。
- 局部变量表
    * 存放编译期可知的各种基本数据类型，引用类型，returnAddress类型
    * 局部变量表的内存空间在编译期完成分配，当进入一个方法时，这个方法需要在帧分配多少内存是固定的，在方法运行期间是不会改变局部变量表的大小。
- 大小
    * StackOverflowError
    * OutOfMemoryError

#### Java堆
- 存放对象实例
- 垃圾收集器管理的主要区域
- 新生代、老年代

#### 方法区
- 存储虚拟机加载的类信息，常亮，静态变量，及时编译器编译后的代码等数据
    * 类的版本
    * 字段
    * 方法
    * 接口
- 方法区和永久代
- 垃圾回收在方法区的行为
- 异常的定义

# 对象浅析
## 对象的创建
- 给对象分配内存
- 线程安全性问题
- 初始化对象
- 执行初始化方法

## 给对象分配内存
- 指针碰撞
- 空闲列表

## 线程安全性问题
- 线程同步
- 本地线程分配缓冲

## 对象的结构
- Header（对象头）
    * 自身运行时的数据（Mark Word）
        - 哈希值 GC分待年龄 锁状态标志 线程持有的锁 偏向线程ID 偏向时间戳
    * 类型指针
- InstanceData
- Padding

HotSpot虚拟机对象头Mark Word.png